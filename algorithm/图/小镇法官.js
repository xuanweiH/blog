// 在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。
// 如果小镇的法官真的存在，那么：
// 小镇的法官不相信任何人。
// 每个人（除了小镇法官外）都信任小镇的法官。
// 只有一个人同时满足属性 1 和属性 2 。
// 给定数组 trust ，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。
// 如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1 。
// 示例 1：
// 输入：N = 2, trust = [[1,2]]
// 输出：2
// 示例 2：
// 输入：N = 3, trust = [[1,3],[2,3]]
// 输出：3
// 示例 3：
// 输入：N = 3, trust = [[1,3],[2,3],[3,1]]
// 输出：-1
// 示例 4：
// 输入：N = 3, trust = [[1,2],[2,3]]
// 输出：-1
// 示例 5：
// 输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
// 输出：3
// 提示：
// 1 <= N <= 1000
// trust.length <= 10000
// trust[i] 是完全不同的
// trust[i][0] != trust[i][1]
// 1 <= trust[i][0], trust[i][1] <= N

// 思路 图的入度和出度
// 入度 有向图的某个顶点作为终点的次数和。
// 出度 有向图的某个顶点作为起点的次数和
// 作为小镇的法官 不相信任何人 所以不会是起点 出度为0
// 但是每个人都信任他 所以终点次数为N-1 
function getPerson (N, trust) {
   // 构造一个图
   let graph = Array.from({length:N+1},()=> ({inDegree:0, outDegree:0}))
   trust.forEach(([a,b]) => {
      graph[a].outDegree++
      graph[b].inDegree++
   })
   return graph.findIndex(({inDegree,outDegree},index)=>{
       return index!==0 && inDegree===N-1 && outDegree===0
   })

}